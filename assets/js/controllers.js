'use strict';

/* Controllers */

function IndexCtrl($scope, $http) {
	//$scope.method = function;
	//$scope.refresh();
}

function ModelsCtrl() {}

function ModelsListCtrl($scope, $http) {
	$http.get("/models").then(function(data) {
		//massage both the object of models and the
		//attributes of each model to arrays for the
		//template
		var models = [];
		for (var prop in data.data) {
			var massagedData = data.data[prop];

			//massage attr
			var attributes = [];
			for (var attr in massagedData.schema) {
				massagedData.schema[attr].key = attr;
				attributes.push(massagedData.schema[attr]);
			}

			massagedData.schema = attributes;
			models.push(massagedData);
		}
		$scope.models = models;
		$scope.autoGenerated = autoGenerated;
	});
}

function ModelsDetailsCtrl($scope, $http, $routeParams, sharedService) {
	$http.get("/models").then(function(data) {
		$scope.model = data.data[$routeParams.id];
		$scope.attributes = [];

		for (var attr in $scope.model.schema) {
			var newObj = {};
			for (var prop in $scope.model.schema[attr]) {
				if (typeof $scope.model.schema[attr][prop] !== 'object') {
					newObj[prop] = $scope.model.schema[attr][prop];
				}
			}
			newObj._key = attr;
			$scope.attributes.push(newObj);
		}
		$scope.autoGenerated = autoGenerated;

		//show auto-generated if those are the only properties the model has
		$scope.showAutoGenerated = hasOnlyAutoGeneratedProperties($scope.model.schema);

		$scope.updateModel = function() {
			var toSend = [];
			$scope.attributes.forEach(function(attr) {
				if (!autoGenerated(attr._key)) {
					toSend.push({
						name: attr._key || '',
						type: attr.type || ''
					});
				}
			});
			$scope.saved = false;
			$scope.error = '';

			$http({
				method: 'POST',
				url: "/models/scaffold",
				data: {
					name: $scope.model.globalId,
					attributes: toSend
				}
			}).then(function(data) {
				if (data.data.success) {
					$scope.saved = true;
					sharedService.prepForBroadcast('changesUpdated');
				} else if (data.data.error) {
					$scope.error = data.data.error;
				}
			});
		};

		$scope.addProperty = function() {
			$scope.attributes.push({});
		};


		$scope.clearError = function() {
			$scope.error = '';
		};

		$scope.clearSaved = function() {
			$scope.saved = '';
		};

		$scope.generateCommand = function() {
			var str = '';
			$scope.attributes.forEach(function(attr) {
				if (!autoGenerated(attr._key)) {
					str += attr._key || '' + ':' + attr.type || '';
					if (str !== '') {
						str += ' ';
					}
				}
			});
			return 'sails scaffold model ' + $scope.model.gloablId + str;
		};
	});
}


function ModelsScaffoldCtrl($scope, $http, sharedService) {
	$scope.modelName = '';

	$scope.generateCommand = function() {
		return 'sails scaffold model ' + $scope.modelName;
	};

	$scope.scaffold = function() {
		if ($scope.modelName) {
			$scope.saved = false;
			$scope.error = '';
			$http({
				method: 'POST',
				url: "/models/scaffold",
				data: {
					name: $scope.modelName
				}
			}).then(function(data) {
				if (data.data.success) {
					$scope.saved = true;
					$scope.modelName = '';
					sharedService.prepForBroadcast('changesUpdated');
				} else if (data.data.error) {
					$scope.error = data.data.error;
				}
			});
		}
	};

	$scope.clearError = function() {
		$scope.error = '';
	};

	$scope.clearSaved = function() {
		$scope.saved = '';
	};
}

function NavCtrl($scope, $location, sharedService) {
	$scope.navClass = function(page, opt) {
		var currentRoute = $location.path().substring(1) || 'index';
		if (opt === 'contains') {
			return currentRoute.indexOf(page) !== -1 ? 'active' : '';
		}
		return page === currentRoute ? 'active' : '';
	};

	$scope.pendingChanges = false;

	$scope.$on('handleBroadcast', function() {
		if (sharedService.message === 'changesUpdated') {
			$scope.pendingChanges = true;
		}
	});
}

/* Helpers */
var autoGeneratedProperties = [
	'id',
	'createdAt',
	'updatedAt'];

function autoGenerated(prop) {
	if (autoGeneratedProperties.indexOf(prop) !== -1) {
		return true;
	}
	return false;
}

function hasOnlyAutoGeneratedProperties(schema) {
	for (var property in schema) {
		if (!autoGenerated(property)) {
			return false;
		}
	}
	return true;
}