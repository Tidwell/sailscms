'use strict';

/* Controllers */

function IndexCtrl($scope, $http) {
	//$scope.method = function;
	//$scope.refresh();
}

function ModelsCtrl() {}

function ModelsListCtrl($scope, $http) {
	$http.get("/models").then(function(data) {
		//massage both the object of models and the
		//attributes of each model to arrays for the
		//template
		var models = [];
		for (var prop in data.data) {
			var massagedData = data.data[prop];

			//massage attr
			var attributes = [];
			for (var attr in massagedData.schema) {
				massagedData.schema[attr].key = attr;
				attributes.push(massagedData.schema[attr]);
			}

			massagedData.schema = attributes;
			models.push(massagedData);
		}
		$scope.models = models;
		$scope.autoGenerated = autoGenerated;
	});
}

function ModelsDetailsCtrl($scope, $http, $routeParams, sharedService) {
	//get the list of all models
	$http.get("/models").then(function(data) {
		//determine if this is existing or new
		$scope.model = data.data[$routeParams.id] || { model:{schema:{}, globalId: ''} };
		//if new set a flag
		if (!$scope.model.globalId) {
			$scope.isNew = true;
		}
		//manipulate the attributes into something easy for the template
		$scope.attributes = [];
		for (var attr in $scope.model.schema) {
			var newObj = {};
			for (var prop in $scope.model.schema[attr]) {
				if (typeof $scope.model.schema[attr][prop] !== 'object') {
					newObj[prop] = $scope.model.schema[attr][prop];
				}
			}
			newObj._key = attr;
			$scope.attributes.push(newObj);
		}

		//add the autogenerated method
		$scope.autoGenerated = autoGenerated;

		//show auto-generated if those are the only properties the model has
		$scope.showAutoGenerated = hasOnlyAutoGeneratedProperties($scope.model.schema);

		//called when the update/create button is clicked
		$scope.updateModel = function() {
			//generate clean copies of the attributes
			var toSend = [];
			$scope.attributes.forEach(function(attr) {
				if (!autoGenerated(attr._key)) {
					toSend.push({
						name: attr._key || '',
						type: attr.type || ''
					});
				}
			});

			//clear flags
			$scope.saved = false;
			$scope.error = '';

			//make request
			$http({
				method: 'POST',
				url: "/models/scaffold",
				data: {
					name: $scope.model.globalId,
					attributes: toSend
				}
			}).then(function(data) {
				if (data.data.success) {
					//set flag and fire pubsub event
					$scope.saved = true;
					sharedService.prepForBroadcast('changesUpdated');
				} else if (data.data.error) {
					$scope.error = data.data.error;
				}
			});
		};

		/* adds a new property */
		$scope.addProperty = function() {
			$scope.attributes.push({});
		};

		/* close buttons on error/saved (todo replace w angular-bootstrap) */
		$scope.clearError = function() {
			$scope.error = '';
		};
		$scope.clearSaved = function() {
			$scope.saved = '';
		};

		/* generates the command the server will execute */
		$scope.generateCommand = function() {
			var str = '';
			$scope.attributes.forEach(function(attr) {
				if (!autoGenerated(attr._key)) {
					//parse each non-auto-generated attribute into key:type
					if (attr._key) {
						str += (attr._key || '') + ':' + (attr.type || '');
					}
					//add a space between each attribute
					if (str !== '') {
						str += ' ';
					}
				}
			});
			return 'sails scaffold model ' + ($scope.model.globalId || '') + ' ' + str;
		};
	});
}

function NavCtrl($scope, $location, sharedService) {
	$scope.navClass = function(page, opt) {
		var currentRoute = $location.path().substring(1) || 'index';
		if (opt === 'contains') {
			return currentRoute.indexOf(page) !== -1 ? 'active' : '';
		}
		return page === currentRoute ? 'active' : '';
	};

	/* if there are pending server changes requiring restart */
	$scope.pendingChanges = false;
	$scope.$on('handleBroadcast', function() {
		if (sharedService.message === 'changesUpdated') {
			$scope.pendingChanges = true;
		}
	});
}

/* Helpers */
var autoGeneratedProperties = [
	'id',
	'createdAt',
	'updatedAt'
];

function autoGenerated(prop) {
	if (autoGeneratedProperties.indexOf(prop) !== -1) {
		return true;
	}
	return false;
}

function hasOnlyAutoGeneratedProperties(schema) {
	for (var property in schema) {
		if (!autoGenerated(property)) {
			return false;
		}
	}
	return true;
}